from knapsack import KnapsackInstance, KnapsackAllocation
from dataclasses import dataclass
import random
import math


"""
Idea: 
-> We encode a knapsack as [0, 0, 0, ..., 0]
-> A neighbour can be randomly generated (exact, but inefficient)
-> A neighbour can be generated by randomly flipping values
    -> [0, 0, 0, 0]
    -> [0, 1, 0, 0]
    -> [1, 0, 1, 0]
-> Perhaps we can only flip one value at a time?
    -> [0, 0, 0, 0]
    -> [1, 0, 0, 0]
    -> [0, 0, 0, 0]
    -> [1, 0, 0, 0]
    -> [1, 0, 1, 0]
    -> [1, 1, 1, 0]
    -> ...
-> The cost can be computed by simply adding or removing the value of the flipped item
-> The weight can be computed by adding or removing the weight

-> What if the weight exceeds the capacity?
    -> We can either keep generating neighbours, but this may lead to non-halting.
    -> We can just skip that iteration when a non-valid neighbour is produced.
"""


@dataclass
class SAKnapsack:
    instance: KnapsackInstance
    allocation: list
    value: int
    weight: int

    def neighbour(self):
        _allocation: list = self.allocation[:]
        _value: int = self.value
        _weight: int = self.weight

        ridx: int = random.randint(0, len(_allocation) - 1)
        if _allocation[ridx]:
            _allocation[ridx] = 0
            _value -= self.instance.items[ridx].value
            _weight -= self.instance.items[ridx].weight
        elif self.instance.items[ridx].weight <= self.instance.capacity:
            while self.instance.capacity - _weight < self.instance.items[ridx].weight:
                inc_indexes: list = [idx for idx, val in enumerate(_allocation) if val]
                to_remove: int = random.choice(inc_indexes)
                _allocation[to_remove] = 0
                _value -= self.instance.items[to_remove].value
                _weight -= self.instance.items[to_remove].weight
            
            _allocation[ridx] = 1
            _value += self.instance.items[ridx].value
            _weight += self.instance.items[ridx].weight

        return SAKnapsack(self.instance, _allocation, _value, _weight)


def __create_sa_knapsack(instance: KnapsackInstance):
    allocation: list = [0] * len(instance.items)
    value: int = 0
    weight: int = 0
    return SAKnapsack(instance, allocation, value, weight)


# Simulated Annealing Parameters
INITIAL_TEMPERATURE: float = 1.0
TEMPERATURE_LENGTH: float = 100
COOLING_RATIO: float = 0.99
NUM_NON_IMPROVE: int = 1000


def simulated_annealing_solver(instance: KnapsackInstance) -> KnapsackAllocation:
    curr_temp: float = INITIAL_TEMPERATURE
    cnt_num_non_improve: int = 0

    curr_allocation: SAKnapsack = __create_sa_knapsack(instance)
    best_allocation: SAKnapsack = curr_allocation

    while cnt_num_non_improve < NUM_NON_IMPROVE:
        for _ in range(TEMPERATURE_LENGTH):
            neig_allocation: SAKnapsack = curr_allocation.neighbour()
            value_increase: int = neig_allocation.value - curr_allocation.value
            if value_increase >= 0:
                curr_allocation = neig_allocation
                if curr_allocation.value > best_allocation.value:
                    best_allocation = curr_allocation
                    cnt_num_non_improve = 0
                else:
                    cnt_num_non_improve += 1
            else:
                q = random.uniform(0, 1)
                p = pow(math.e, -value_increase / curr_temp)
                if q < p:
                    curr_allocation = neig_allocation
                cnt_num_non_improve += 1
        
        curr_temp *= COOLING_RATIO
    
    result = [idx for idx, val in enumerate(best_allocation.allocation) if val]
    return KnapsackAllocation(result, best_allocation.value)
